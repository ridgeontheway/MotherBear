import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton, QAction, QToolBar, QMessageBox, QLabel, QProgressBar, QComboBox, QStyleFactory
from PyQt5.QtGui import *


class Window(QMainWindow):

    # if we have a main menu, this is going to go into __init__ since we want it to generate as soon as our window is
    # generated -- think of it as the template that the rest of the program is going to work on
    def __init__(self):
        super(Window, self).__init__()
        self.setGeometry(50, 50, 500, 300)
        self.setWindowTitle("MotherBear")

        extract_action = QAction("&Does this work???", self)
        # A keyboard shortcut for the file action
        extract_action.setShortcut("Ctrl+Q")
        extract_action.setStatusTip("Leave the app?")
        extract_action.triggered.connect(lambda: self.close_window())

        # Declaring the menu bar
        main_menu = self.menuBar()
        # gets rid of issues with the gloabl fullscreen menu like they have on unity + OSX
        main_menu.setNativeMenuBar(False)

        file_menu = main_menu.addMenu('&File')
        file_menu.addAction(extract_action)

        self.home()

    def home(self):
        btn = QPushButton("Quit", self)
        # need to use lambda because it is expecting a callable function
        btn.clicked.connect(lambda: self.close_window())

        # will just return the size it recommends based on the other stuff thats going on
        btn.resize(btn.sizeHint())
        btn.move(0, 100)

        # Showing how we can add a toolbar, maybe useful when we actually get round to creating the connections
        extract_action = QAction(QIcon('python_logo.png'), "This is a logo?", self)
        extract_action.triggered.connect(lambda: self.close_window())

        toolbar = QToolBar("Extraction")
        toolbar.addAction(extract_action)


        self.addToolBar(toolbar)

        # Showing how we can add a toolbar, maybe useful when we actually get round to creating the connections
        font_choice = QAction('Font', self)
        font_choice.triggered.connect(lambda: self.font_choice)
        toolbar = self.addToolBar("Font")
        toolbar.addAction(font_choice)

        # Code for a checkbox
        # self.checkBox = QCheckBox("Enlarge Window", self)
        # self.checkBox.move(100, 25)
        # self.checkBox.stateChanged.connect(lambda: self.enlarge_window(self.checkBox))

        # Code the the qprogress bar
        # Not 100% sure but the self reffers to this objects GLOBAL attributes (the non-self is just the local vars)
        self.progress = QProgressBar(self)
        self.progress.setGeometry(200, 80, 250, 20)
        # Code to trigger the progress bar
        self.btn = QPushButton("Download", self)
        self.btn.clicked.connect(self.download)
        self.btn.move(200, 120)

        # Code for a drop down button which will change the style of the window when pressed
        self.styleChoice = QLabel("Windows Vista", self)
        # The comboBox is actually the dropdown menu, kind of confusing
        comboBox = QComboBox(self)
        # These are the ones on qt4, need to look up the ones on qt5 if I want to include this (probably just want a dark and light mode tbh)
        comboBox.addItem("Motif")
        comboBox.addItem("Windows")
        comboBox.addItem("Cde")
        comboBox.addItem("Plastique")
        comboBox.addItem("Cleanlooks")

        comboBox.move(50, 250)
        self.styleChoice.move(51, 50)
        comboBox.activated[str].connect(self.style_choice)

        self.show()

    def style_choice(self, text):
        self.styleChoice.setText(text)
        QApplication.setStyle(QStyleFactory.create(text))

    def enlarge_window(self, state):
        if state.isChecked():
            self.setGeometry(50,50, 1000, 600)
        else:
            self.setGeometry(50, 50, 500, 300)

    def download(self):
        # This doesnt actually do anything, just calls the progress bar
        self.completed = 0

        while self.completed < 100:
            self.completed += 0.0001
            self.progress.setValue(self.completed)

    def close_window(self):
        # Using the QMessagebox to ask the user if we want to close the program or not
        choice = QMessageBox.question(self, "what does this do?", "Close the app?", QMessageBox.Yes | QMessageBox.No)
        if choice == QMessageBox.Yes:
            print("We are now closing the program...")
            sys.exit()
        else:
            pass


def run():
    app = QApplication([])
    GUI = Window()
    sys.exit(app.exec_())


run()

from Controller.ControllerLogic import ControllerLogic

if __name__ == '__main__':
    cachedInitialLogic = ControllerLogic()
    cachedInitialLogic.StartApplication()

